"""
Learning Tool - Educational Questions with Google Search Grounding

Uses Gemini with Google Search grounding to answer educational questions
with accurate, cited information.
"""

import logging
from typing import Dict, Any, Optional
from datetime import datetime, timedelta

logger = logging.getLogger(__name__)


class LearningTool:
    """Educational question answering with Google Search grounding."""
    
    def __init__(self, gemini_model=None):
        """
        Initialize learning tool with Gemini model.
        
        Args:
            gemini_model: Gemini model instance for grounded generation
        """
        self.gemini = gemini_model
        self.cache = {}
        self.cache_ttl = 3600  # 1 hour cache for educational content
        
        if not self.gemini:
            logger.warning("Learning tool initialized without Gemini model")
    
    async def answer_question(
        self, 
        question: str, 
        learning_level: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Answer educational question using Google Search grounding.
        
        Args:
            question: The educational question to answer
            learning_level: Optional learning level (beginner/intermediate/advanced)
            
        Returns:
            Dict with:
                - answer: Main answer text
                - citations: List of source URLs
                - confidence: Grounding confidence
                - error: Error message if failed
        """
        # Check cache first
        cache_key = f"{question}:{learning_level or 'default'}"
        if cache_key in self.cache:
            age = (datetime.now() - self.cache[cache_key]['timestamp']).total_seconds()
            if age < self.cache_ttl:
                logger.info(f"ðŸ“š Cache HIT for learning question")
                return self.cache[cache_key]['data']
        
        if not self.gemini:
            return {
                "error": "model_not_configured",
                "answer": "Educational service not configured.",
                "citations": []
            }
        
        try:
            
            # Adjust prompt based on learning level
            level_instruction = ""
            if learning_level:
                level_map = {
                    "beginner": "Explain in simple terms suitable for someone without prior knowledge.",
                    "intermediate": "Provide a balanced explanation with some technical details.",
                    "advanced": "Give a detailed, technical explanation."
                }
                level_instruction = level_map.get(learning_level.lower(), "")
            
            # Construct educational prompt
            prompt = f"""{level_instruction}

Question: {question}

Provide a clear, accurate answer in 2-3 sentences."""

            # Generate with Google Search grounding
            # Import Tool type
            from google.generativeai.types import Tool, GoogleSearch
            
            # Generate with Google Search grounding
            response = self.gemini.generate_content(
                prompt,
                generation_config={
                    "temperature": 0.3,
                },
                tools=[Tool(google_search=GoogleSearch())]
            )
            )
            
            # Extract answer
            answer = response.text.strip() if response.text else "I couldn't find information on that topic."
            
            # Extract citations from grounding metadata
            citations = []
            confidence = "medium"
            
            if hasattr(response, 'grounding_metadata') and response.grounding_metadata:
                # Extract source URLs
                if hasattr(response.grounding_metadata, 'grounding_chunks'):
                    for chunk in response.grounding_metadata.grounding_chunks:
                        if hasattr(chunk, 'web') and hasattr(chunk.web, 'uri'):
                            # Extract domain name for cleaner citations
                            uri = chunk.web.uri
                            domain = uri.split('//')[1].split('/')[0] if '//' in uri else uri
                            if domain not in citations:
                                citations.append(domain)
                
                # Get confidence if available
                if hasattr(response.grounding_metadata, 'grounding_support'):
                    support = response.grounding_metadata.grounding_support
                    if hasattr(support, 'grounding_chunk_indices') and support.grounding_chunk_indices:
                        confidence = "high"
            
            # Limit citations to top 3
            citations = citations[:3]
            
            result = {
                "answer": answer,
                "citations": citations,
                "confidence": confidence
            }
            
            # Cache the result
            self.cache[cache_key] = {
                'data': result,
                'timestamp': datetime.now()
            }
            
            logger.info(f"âœ… Learning: Answered with {len(citations)} citations")
            return result
            
        except Exception as e:
            logger.error(f"Learning tool error: {e}")
            import traceback
            traceback.print_exc()
            
            return {
                "error": "generation_failed",
                "answer": "I'm having trouble finding information on that right now.",
                "citations": []
            }


_learning_tool_instance = None


def get_learning_tool():
    """Get or create learning tool singleton."""
    global _learning_tool_instance
    
    if _learning_tool_instance is None:
        from app.services.gemini import get_gemini_service
        gemini_service = get_gemini_service()
        _learning_tool_instance = LearningTool(gemini_service.model)
    
    return _learning_tool_instance
